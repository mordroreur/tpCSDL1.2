% Created 2021-12-03 Fri 14:31
% Intended LaTeX compiler: pdflatex
\documentclass[letter]{article}
                      \usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage[a4paper,left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage[frenchb, ]{babel}
\usepackage{libertine}
\usepackage[pdftex]{graphicx}
\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}
\newcommand{\hsp}{\hspace{20pt}}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\usepackage{lastpage} %les latex header ici
\date{\today}
\title{}
\begin{document}

%chargement de la page de garde
\input{$PWD/Latex/Setupfile/Pagedegarde/Pagedegarde1/pagedegarde1.org}




\setcounter{tocdepth}{2}
\tableofcontents

\newpage


\section{Problèmes potentiels identifiés au départ}
\label{sec:org32da960}

Ce jeu à en effet quelques spécificités :

\subsection{Gestion des fusions}
\label{sec:org7c91f4f}

Tout d'abord, le jeu peut fusionner plusieurs cases en même temps, sur différentes lignes et colonnes. De plus, sur ces mêmes lignes et colonnes comme, par exemple, avec cet exemple :

\begin{center}
\begin{tabular}{rrrr}
2 & 2 & 4 & 4\\
4 & 8 & 2 & 2\\
0 & 0 & 0 & 0\\
0 & 0 & 0 & 0\\
\end{tabular}
\end{center}

Si le joueur fusionne à gauche, nous devrons fusionner les deux ET les 4 présents sur la première ligne.

De plus, lorsque l'on doit fusionner plusieurs cases, nous devons mettre les résultats de la fusion “collés” dans la direction voulue.
Nous devons donc gérer ce cas en plusieurs étapes.

\subsection{Différentes taille}
\label{sec:orgb30459e}

Nous souhaitons faire plusieurs tailles de 2048, nous voulons donc avoir la possibilité de changer la taille de la grille.

\subsection{Gestion des sauvegardes}
\label{sec:org76ecd61}

Nous voulons que notre joueur puisse faire une pause. Nous nous imposons donc de faire un système de sauvegarde rapide et efficace.



\section{Présentation du programme console}
\label{sec:org0ffd9a7}

Nous ne mettrons pas l'intégralité du code des différentes résolutions, mais il est consultable dans les fichiers joints.

\subsection{Introduction à la structure Terrain/ter}
\label{sec:orgb4268e1}

Nous avons choisis d'utiliser une structure pour notre Terrain pour pouvoir manipuler notre grille aisément.

\begin{verbatim}

  typedef struct Terrain{
  int **tab;
  int max;
  int tailleX;
  int tailleY;
  int vide;
  int score;
}ter;



\end{verbatim}

Elle est composé de divers éléments, mais seulement d'entiers :

\begin{enumerate}
\item Un tableau en 2 dimensions, qui serra la grille en elle même.
\item max, qui sera l'entier présent dans la grille maximal. Permet de gérer le cas de “victoire” si l'on fait 2048.
\item tailleX, qui sera le nombre de colonne
\item tailleY, qui sera le nombre de ligne
\item vide, qui sera le nombre de case vide du tableau
\item score, qui sera le score du Terrain en cours
\end{enumerate}


Toutes ces éléments sont présents pour simplifier le nombre de paramètre pris par les divers fonctions suivantes.




\subsection{Présentation des différentes fonctions  avec leurs signatures}
\label{sec:org1aa6e88}

\subsubsection{InitVide}
\label{sec:org9eeaa9b}

\begin{verbatim}
ter InitVide(int n, int y);
\end{verbatim}

Cette fonction prend deux entier et renvoie un ter de la taille de \emph{n} et de \emph{y}.
Elle nous permet de créer notre grille proprement.

\subsubsection{afficheTer}
\label{sec:org77b2d18}

\begin{verbatim}
void afficheTer(ter T);
\end{verbatim}

afficheTer nous permet, comme son nom l'indique, d'afficher le ter donné en paramètre.

\subsubsection{SetRandomCase}
\label{sec:org760c4c9}

\begin{verbatim}
int SetRandomCase(ter *T, int n);
\end{verbatim}

SetRandomCase permet d'initialiser une case \texttt{vide} à une certain valeur. Elle prend en paramètre un entier, qui détermine l'emplacement de la case. Petit particularité : le nombre de case \emph{n} ne s'incrémente pas si la case est déjà rempli. C'est donc après \emph{n} case vide que l'on initialise la case numéro \emph{n} + \textbf{nombre de case déjà remplie} à une valeur 2 ou 4.

\subsubsection{CaseMouve}
\label{sec:orgf9c39a8}

\begin{verbatim}
void CaseMouve(ter *T, int depNum);
\end{verbatim}

Cette fonction est sûrement une des plus importante. En effet, elle prend en paramètre un pointeur sur un terrain ainsi qu'un déplacement. 
Par manque de place sur ce rapport, nous ne pouvons la décrire entièrement. En revanche, le code de cette fonction est particulièrement bien détaillé et est disponible dans \href{FonctionJeu.c}{Fonction.c}.
Dépend de la fonction \hyperref[sec:org42dfd89]{CanDep} pour vérifier si le joueur peut se déplacer ou à perdu.

\subsubsection{{\bfseries\sffamily TODO} CanDep}
\label{sec:org42dfd89}

\begin{verbatim}
int CanDep(ter T, int depNum);
\end{verbatim}



Également essentielle, cette fonction permet de savoir si le

Nous avons géré le game over comme ceci (\href{main.c}{dans le main.c}) :
\begin{verbatim}
for(int i = 1;i < 5; i++){
	      if(CanDep(plateau, i)){
		// si le joueur peu bouger on change cette variable
		GameOver = 0;
		break;
	      }
	    }
\end{verbatim}


\subsubsection{LibereTer}
\label{sec:org202c82b}

\begin{verbatim}
void LibereTer(ter *T);
\end{verbatim}

\subsubsection{ReadEnCoursSave}
\label{sec:orge8f4271}



\subsubsection{copiFile}
\label{sec:org8b1382e}

\begin{verbatim}
void copiFile(char *old, char *nouv);
\end{verbatim}

Cette fonction permet de prendre deux chaînes de caractères qui sont les noms de fichiers, et qui copi \emph{old} dans \emph{nouv}.

\subsubsection{writesaveFile}
\label{sec:org92a1e2b}

\subsection{Explication du fonctionnement du jeu de base}
\label{sec:org9c76c47}

\subsection{Présentation des nouvelles fonctionnalités}
\label{sec:orgdb3a22f}


\subsubsection{Possibilité de mapper les touches de déplacement}
\label{sec:org49421fe}

\subsubsection{Fichier paramètre}
\label{sec:org02b90ca}

Le fichier paramètre s'appelle Parametres, et posséde plusieurs éléments



usleep((int)(1000000*time));
// on effectue le deplacement deja effectue par le joueur
CaseMouve(\&T, depNum);

stocker le nombre de case vide, et


un fichier moddifiable
Param\textsubscript{Name}

High score
Nb de victoire
Nb de défaite
les nouvelles touches*4
nb de replay (pour le nom du fichier des replays au fur et à mesure)


\subsubsection{Gestion des sauvegardes}
\label{sec:org5920778}

\begin{enumerate}
\item Présentation du fichier de sauvegarde
\label{sec:org526f538}




Un fichier de sauvegarde est présenter de cette manière :
Unelettre Unchiffre Unautrechiffre
Unelettre Unchiffre Unautrechiffre Unelettre Unchiffre Unautrechiffre Unelettre Unchiffre Unautrechiffre [\ldots{}]

Un exemple concret :
\begin{verbatim}
N 4 2
n 2 3 n 2 4 h 2 3 b 2 2 g 2 4 g 
\end{verbatim}

Tout d'abord, les trois premiers éléments :
\begin{enumerate}
\item Sert à déterminer le “type” de la sauvegarde.
\item Les deux nombres suivant permette d'avoir la taille du terrain
\end{enumerate}

Puis, les autres sont simplement la partie enregistrer.
Comment me direz vous ?
Et bien, la lettre donne la direction (g gauche, etc, n rien (c'est le moment où l'on ajoute à une case vide le chiffe 2 ou 4)), le deuxième nombre donne la valeur obtenue lors de la génération aléatoire, et le dernier donne l'emplacement où ce nombre est apparu en suivant le \hyperref[sec:org9f990e6]{principe suivant}.


\item La sauvegarde en elle-même
\label{sec:orga34f6bc}

La gestion des sauvegardes est particulière.
En effet, lorsque le joueur joue un coup, nous enregistrons, selon la méthode décrite \hyperref[sec:org526f538]{ici}, les différents éléments nécessaires à la sauvegarde.
C'est-à-dire qu'à chaque fois que le joueur effectue un coup, nous récupérons les éléments nécessaires pour pouvoir simuler cette partie.

\item Récupération de la sauvegarde (avec \hyperref[sec:orge8f4271]{ReadEnCoursSave})
\label{sec:org9f990e6}

La sauvegarde est récupérée en deux étapes :

\begin{enumerate}
\item Lecture du fichier
\label{sec:orgbe94e85}

Pour lire le fichier de sauvegarde, nous avons besoin de la fonction \hyperref[sec:orge8f4271]{ReadEnCoursSave}. En effet, cette fonction permet de lire les informations présentes dans le fichier de sauvegarde donné

\begin{verbatim}
FILE *save = fopen(SAVE_NAME, "r");
\end{verbatim}

où SAVE\textsubscript{NAME} est une macro qui est le nom du fichier de la sauvegarde (non modifiable par le joueur).

De plus, cette fonction permet de recréer un exactement le même terrain de la sauvegarde avec, on l'avoue, un petit subterfuge :



\item Replay automatique
\label{sec:org0afd7c8}

Lors de l'appel de la fonction, nous créons d'abord le terrain avec le tableau de la bonne dimension. Nous lisons donc la première ligne.
Puis, nous parcourons la deuxième. Nous stockons dans une chaîne de caractère un seul et unique coup. Nous avons donc besoin de stocker une lettre et 2 nombre.
Le fichier de sauvegarde ressemblant à ceci :

\begin{verbatim}
N unnombre unautre
n 2 31 n 2 4 h 2 3 b 2 22 g 2 4 g 
\end{verbatim}

nous devons compter le nombre d'espace, et non le nombre de caractère (ici nous avons 31 et 22 qui ne marcherait pas) pour séparer deux coup. Quand ce nombre d'espace atteint 3, nous somme donc en présence du coup suivant.
\end{enumerate}
\end{enumerate}


\subsubsection{Replays}
\label{sec:orgbcb4959}



\section{SDL}
\label{sec:orgfc5bbfc}

Le code qui nous permet de gérer la fenêtre SDL est disponible \href{render.c}{ici}.

\subsection{Début}
\label{sec:org3c0b1e5}

Pour démarrer SDL, nous devons initialiser de nombreuses variables, comme par exemple :

\begin{itemize}
\item La variable \emph{Stape}, qui nous permet de fermer SDL si elle est égale à 0,
\item \emph{size}, qui va nous permettre de gérer la taille de l'écran,
\item des variables permettant de garder un nombre d'image par seconde (fps) constant et agréable
\item des variables permettant de détecter où le curseur de la souris se trouve sur l'écran
\item les varibles permettant de dessiner le graphique
\item etc.
\end{itemize}




\subsection{Affichage et fonctionnalité}
\label{sec:orga04fbb7}

\subsubsection{Affichage}
\label{sec:orgb90d9de}

Pour effectuer l'affichage d'une fenêtre SDL, nous devons passer par une boucle \emph{while}.

Puis, nous distinguerons trois cas grâce à un \emph{if} (et \emph{else if}).

\begin{enumerate}
\item Dans le premier cas, SDL dessinera l'écran, s'il n'a pas été dessiné depuis un certain temps
\item Sinon, nous vérifierons également si les courbes sont en adéquation avec les polynômes. Si ce n'est pas le cas, nous entrons alors dans le \emph{else if} qui va nous permettre d'écraser l'image précédente. Enfin,
\item si nous passons les deux conditions précédentes, nous devons \textbf{absolument} endormir le Central Processing Unit (CPU). Cela nous permet de ne pas utiliser tout le processeur de l'ordinateur.
\end{enumerate}

Puis, nous avons aussi un cas de débogage. En effet, si l'on n'est pas entré dans le while depuis une seconde ou plus, il peut y avoir un problème. On recommence alors une seconde "propre", en mettant certaines variables à 0.








\subsubsection{Fonctionnalités :}
\label{sec:orgc9abc89}

Divers fonctionnalités sont présentes :
Vous pouvez afficher la fenêtre grâce à la touche "g". Vous pouvez désormais voir la liste des points, les courbes représentant les différentes méthodes d'approximation, ainsi que la liste de points à droite.

De plus, si jamais vous voulez rajouter des points à la liste, cette fonctionnalité est disponible grâce au bouton gauche de la souris. Le bouton droit aura pour effet de supprimer le point sélectionné.

Le curseur aura alors une position (x et y) qui sera automatiquement ajouté dans la liste des points. Les courbes ainsi que les polynômes vont s'adapter automatiquement !

D'autre part, vous pouvez zoomer et dézoomer grâce à la molette de la souris.

Enfin, vous pouvez activer ou désactiver les différentes courbes des fonctions en appuyant sur leur nom. 


\subsection{Fin de SDL}
\label{sec:org61c6735}

La fonction \emph{end-sdl} nous permet de fermet la fenêtre SDL proprement, ainsi que faire les opérations nécessaires pour vider la mémoire qui a besoin d'être libéré.






\section{Conclusion}
\label{sec:org7c249da}

Maintenant, on vous souhaite bonne chance.
\end{document}