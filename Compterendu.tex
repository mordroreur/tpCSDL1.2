% Created 2021-12-11 Sat 10:54
% Intended LaTeX compiler: pdflatex
\documentclass[letter]{article}
                      \usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage[a4paper,left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage[frenchb, ]{babel}
\usepackage{libertine}
\usepackage[pdftex]{graphicx}
\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}
\newcommand{\hsp}{\hspace{20pt}}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\usepackage{lastpage} %les latex header ici
\date{\today}
\title{}
\begin{document}

%chargement de la page de garde
\input{$PWD/Latex/Setupfile/Pagedegarde/Pagedegarde1/pagedegarde1.org}




\setcounter{tocdepth}{2}
\tableofcontents

\newpage


\section{Problèmes potentiels identifiés au départ}
\label{sec:org65bcba3}

Ce jeu à en effet quelques spécificités :

\subsection{Gestion des fusions}
\label{sec:org2d499ad}

Tout d'abord, le jeu peut fusionner plusieurs cases en même temps, sur différentes lignes et colonnes. De plus, sur ces mêmes lignes et colonnes comme, par exemple, avec cet exemple :

\begin{center}
\begin{tabular}{rrrr}
2 & 2 & 4 & 4\\
4 & 8 & 2 & 2\\
0 & 0 & 0 & 0\\
0 & 0 & 0 & 0\\
\end{tabular}
\end{center}

Si le joueur fusionne à gauche, nous devrons fusionner les deux ET les 4 présents sur la première ligne.

De plus, lorsque l'on doit fusionner plusieurs cases, nous devons mettre les résultats de la fusion “collés” dans la direction voulue.
Nous devons donc gérer ce cas en plusieurs étapes.

\subsection{Différentes taille}
\label{sec:org1e4672e}

Nous souhaitons faire plusieurs tailles de 2048, nous voulons donc avoir la possibilité de changer la taille de la grille.

\subsection{Gestion des sauvegardes}
\label{sec:orgcf11b20}

Nous voulons que notre joueur puisse faire une pause. Nous nous imposons donc de faire un système de sauvegarde rapide et efficace.



\section{Présentation du programme console}
\label{sec:org8bf5eb3}

Nous ne mettrons pas l'intégralité du code des différentes résolutions, mais il est consultable dans les fichiers joints.

\subsection{Introduction à la structure Terrain/ter}
\label{sec:org13c0a0d}

Nous avons choisis d'utiliser une structure pour notre Terrain pour pouvoir manipuler notre grille aisément.

\begin{verbatim}

  typedef struct Terrain{
  int **tab;
  int max;
  int tailleX;
  int tailleY;
  int vide;
  int score;
}ter;



\end{verbatim}

Elle est composé de divers éléments, mais seulement d'entiers :

\begin{enumerate}
\item Un tableau en 2 dimensions, qui serra la grille en elle même.
\item max, qui sera l'entier présent dans la grille maximal. Permet de gérer le cas de “victoire” si l'on fait 2048.
\item tailleX, qui sera le nombre de colonne
\item tailleY, qui sera le nombre de ligne
\item vide, qui sera le nombre de case vide du tableau
\item score, qui sera le score du Terrain en cours
\end{enumerate}


Toutes ces éléments sont présents pour simplifier le nombre de paramètre pris par les divers fonctions suivantes.




\subsection{Présentation des différentes fonctions  avec leurs signatures}
\label{sec:orgbb13507}

\begin{enumerate}
\item InitVide
\label{sec:org62d41b5}

\begin{verbatim}
ter InitVide(int n, int y);
\end{verbatim}

Cette fonction prend deux entier et renvoie un ter de la taille de \emph{n} et de \emph{y}.
Elle nous permet de créer notre grille proprement.

\item afficheTer
\label{sec:orgf2a5f00}

\begin{verbatim}
void afficheTer(ter T);
\end{verbatim}

afficheTer nous permet, comme son nom l'indique, d'afficher le ter donné en paramètre.

\item SetRandomCase
\label{sec:orga9ef16f}

\begin{verbatim}
int SetRandomCase(ter *T, int n);
\end{verbatim}

SetRandomCase permet d'initialiser une case \texttt{vide} à une certain valeur. Elle prend en paramètre un entier, qui détermine l'emplacement de la case. Petit particularité : le nombre de case \emph{n} ne s'incrémente pas si la case est déjà rempli. C'est donc après \emph{n} case vide que l'on initialise la case numéro \emph{n} + \textbf{nombre de case déjà remplie} à une valeur 2 ou 4.

\item CaseMouve
\label{sec:org0c230d8}

\begin{verbatim}
void CaseMouve(ter *T, int depNum);
\end{verbatim}

Cette fonction est sûrement une des plus importante. En effet, elle prend en paramètre un pointeur sur un terrain ainsi qu'un déplacement. 
Par manque de place sur ce rapport, nous ne pouvons la décrire entièrement. En revanche, le code de cette fonction est particulièrement bien détaillé et est disponible dans \href{FonctionJeu.c}{Fonction.c}.
Dépend de la fonction \hyperref[sec:orgec1067c]{CanDep} pour vérifier si le joueur peut se déplacer ou à perdu.

\item CanDep
\label{sec:orgec1067c}

\begin{verbatim}
int CanDep(ter T, int depNum);
\end{verbatim}

Également essentielle, cette fonction permet de savoir si le

Nous avons géré le game over comme ceci (\href{main.c}{dans le main.c}) :
\begin{verbatim}
for(int i = 1;i < 5; i++){
	      if(CanDep(plateau, i)){
		// si le joueur peu bouger on change cette variable
		GameOver = 0;
		break;
	      }
	    }
\end{verbatim}

Nous testons donc tous les coup grâce à cette fonction à chaque fois après le coup du joueur. Si le joueur peut faire un déplacement, alors \emph{CanDep} retournera 1, ce qui mettra la variable \emph{GameOver} à 0, le joueur n'a pas perdu. Dans le cas contraire, \emph{GameOver} restera à 1 et le joueur aura donc perdu.

\item LibereTer
\label{sec:orga1798dd}

\begin{verbatim}
void LibereTer(ter *T);
\end{verbatim}

Comme son nom l'indique, cette fonction permet simplement de libérer un \emph{ter} proprement.

\item ReadEnCoursSave
\label{sec:org2ded51b}


\begin{verbatim}
ter ReadEnCoursSave(float time, char *name);
\end{verbatim}


Grâce à cette fonction permet, nous pouvons lire le fichier de sauvegarde. Plus de détail dans la suite du document (\hyperref[sec:orgcf11b20]{ici}).

\item copiFile
\label{sec:orga17698c}

\begin{verbatim}
void copiFile(char *old, char *nouv);
\end{verbatim}

Cette fonction permet de prendre deux chaînes de caractères qui sont les noms de fichiers, et qui copie le contenu de \emph{old} dans \emph{nouv}, qui seront les noms des fichiers.

\item writesaveFile
\label{sec:orga53634a}


\begin{verbatim}
void writesaveFile(int hightscore, int endedGamesWin, int endedLoseGame, char mouvsup[4], int nbReplay);
\end{verbatim}

Enfin, cette dernière fonction nous permet de sauvegarder la partie dans un fichier de sauvegarde, en prenant paramètres nécessitant une sauvegarde pour recharger la partie. Plus
de détail dans la suite de ce document (\hyperref[sec:orgcf11b20]{ici})
\end{enumerate}

\subsection{{\bfseries\sffamily TODO} Explication du fonctionnement du jeu de base}
\label{sec:orge1d658f}

Les fonctions étant définis dans \emph{FonctionJeu.c}, le jeu en lui même est entièrement présent dans le \emph{main.c}.

Notre programme est basé sur un switch, qui nous laisse 6 choix (dont 1 de fermuture)

\begin{enumerate}
\item Le premier cas est lors de l'arrivé dans le jeu. Il renvoie systématiquement à :
\item Notre menu, qui est le cas numéro 2. C'est ici que le joueur décide si il veut lancer une nouvelle partie, voir un replay, etc. On peut distinguer 3 cas majeurs :
\begin{itemize}
\item Lancement d'un jeu
\item Voir un replay
\item Quitter le jeu
\end{itemize}
\item Subséquemment, le cas 3 nous permet de gérer les déplacement du joueur ainsi que l’affichage du jeu
\item Ensuite, le quatrième cas permet de gérer lorsque que le joueur à fini la partie. Affiche si il a gagné ou perdu (score </> à 2048), ainsi que son meilleur score.
\item Le cas 5 est le cas où l'initialisation du terrain s'est mal passé. On va alors au cas -1.
\item Le cas 6 est dédié à la modification des paramètre du jeu (tel que les touches par exemple)
\item Enfin, le cas -1, qui est réservé pour arrêter le jeu et le fermer proprement
\end{enumerate}

\subsection{Présentation des nouvelles fonctionnalités}
\label{sec:orga39c03f}

\begin{enumerate}
\item Gestion des sauvegardes
\label{sec:org8335584}

\begin{enumerate}
\item Présentation du fichier de sauvegarde
\label{sec:org7d2c40d}




Un fichier de sauvegarde est présenter de cette manière :
Unelettre Unchiffre Unautrechiffre
Unelettre Unchiffre Unautrechiffre Unelettre Unchiffre Unautrechiffre Unelettre Unchiffre Unautrechiffre [\ldots{}]

Un exemple concret :
\begin{verbatim}
N 4 2
n 2 3 n 2 4 h 2 3 b 2 2 g 2 4 g 
\end{verbatim}

Tout d'abord, les trois premiers éléments :
\begin{enumerate}
\item Sert à déterminer le “type” de la sauvegarde.
\item Les deux nombres suivant permette d'avoir la taille du terrain
\end{enumerate}

Puis, les autres sont simplement la partie enregistrer.
Comment me direz vous ?
Et bien, la lettre donne la direction (g gauche, etc, n rien (c'est le moment où l'on ajoute à une case vide le chiffe 2 ou 4)), le deuxième nombre donne la valeur obtenue lors de la génération aléatoire, et le dernier donne l'emplacement où ce nombre est apparu en suivant le \hyperref[sec:orge1d9381]{principe suivant}.


\item La sauvegarde en elle-même
\label{sec:org0ed3ffd}

La gestion des sauvegardes est particulière.
En effet, lorsque le joueur joue un coup, nous enregistrons, selon la méthode décrite \hyperref[sec:org7d2c40d]{ici}, les différents éléments nécessaires à la sauvegarde.
C'est-à-dire qu'à chaque fois que le joueur effectue un coup, nous récupérons les éléments nécessaires pour pouvoir simuler cette partie.

\item Récupération de la sauvegarde (avec \hyperref[sec:org2ded51b]{ReadEnCoursSave})
\label{sec:orge1d9381}

La sauvegarde est récupérée en deux étapes :

\begin{enumerate}
\item Lecture du fichier
\label{sec:org35e1794}

Pour lire le fichier de sauvegarde, nous avons besoin de la fonction \hyperref[sec:org2ded51b]{ReadEnCoursSave}. En effet, cette fonction permet de lire les informations présentes dans le fichier de sauvegarde donné

\begin{verbatim}
FILE *save = fopen(SAVE_NAME, "r");
\end{verbatim}

où SAVE\textsubscript{NAME} est une macro qui est le nom du fichier de la sauvegarde (non modifiable par le joueur).

De plus, cette fonction permet de recréer un exactement le même terrain de la sauvegarde avec, on l'avoue, un petit subterfuge :



\item Replay automatique
\label{sec:org86a4097}

Lors de l'appel de la fonction, nous créons d'abord le terrain avec le tableau de la bonne dimension. Nous lisons donc la première ligne.
Puis, nous parcourons la deuxième. Nous stockons dans une chaîne de caractère un seul et unique coup. Nous avons donc besoin de stocker une lettre et 2 nombre.
Le fichier de sauvegarde ressemblant à ceci :

\begin{verbatim}
N unnombre unautre
n 2 31 n 2 4 h 2 3 b 2 22 g 2 4 g 
\end{verbatim}

nous devons compter le nombre d'espace, et non le nombre de caractère (ici nous avons 31 et 22 qui ne marcherait pas) pour séparer deux coup. Quand ce nombre d'espace atteint 3, nous somme donc en présence du coup suivant.
\end{enumerate}
\end{enumerate}


\item Possibilité de mapper les touches de déplacement
\label{sec:org1fd6767}

\item Fichier paramètre
\label{sec:org0af3236}

Le fichier paramètre s'appelle Parametres, et posséde plusieurs éléments



usleep((int)(1000000*time));
// on effectue le deplacement deja effectue par le joueur
CaseMouve(\&T, depNum);

stocker le nombre de case vide, et


un fichier moddifiable
Param\textsubscript{Name}

High score
Nb de victoire
Nb de défaite
les nouvelles touches*4
nb de replay (pour le nom du fichier des replays au fur et à mesure)


\item Replays
\label{sec:orgb4af942}
\end{enumerate}



\section{{\bfseries\sffamily TODO} La partie SDL}
\label{sec:org1f8a787}

Le code qui nous permet de gérer la fenêtre SDL est disponible \href{render.c}{ici}.

\subsection{Début}
\label{sec:org60af0cc}

Pour démarrer SDL, nous devons initialiser de nombreuses variables, comme par exemple :

\begin{itemize}
\item La variable \emph{Stape}, qui nous permet de fermer SDL si elle est égale à 0,
\item \emph{size}, qui va nous permettre de gérer la taille de l'écran,
\item des variables permettant de garder un nombre d'image par seconde (fps) constant et agréable
\item des variables permettant de détecter où le curseur de la souris se trouve sur l'écran
\item les varibles permettant de dessiner le graphique
\item etc.
\end{itemize}




\subsection{Affichage et fonctionnalité}
\label{sec:orgb96e69d}

\begin{enumerate}
\item Affichage
\label{sec:orgef1d22a}

Pour effectuer l'affichage d'une fenêtre SDL, nous devons passer par une boucle \emph{while}.

Puis, nous distinguerons trois cas grâce à un \emph{if} (et \emph{else if}).

\begin{enumerate}
\item Dans le premier cas, SDL dessinera l'écran, s'il n'a pas été dessiné depuis un certain temps
\item Sinon, nous vérifierons également si les courbes sont en adéquation avec les polynômes. Si ce n'est pas le cas, nous entrons alors dans le \emph{else if} qui va nous permettre d'écraser l'image précédente. Enfin,
\item si nous passons les deux conditions précédentes, nous devons \textbf{absolument} endormir le Central Processing Unit (CPU). Cela nous permet de ne pas utiliser tout le processeur de l'ordinateur.
\end{enumerate}

Puis, nous avons aussi un cas de débogage. En effet, si l'on n'est pas entré dans le while depuis une seconde ou plus, il peut y avoir un problème. On recommence alors une seconde "propre", en mettant certaines variables à 0.








\item Fonctionnalités :
\label{sec:orgc4502d9}

Divers fonctionnalités sont présentes :
Vous pouvez afficher la fenêtre grâce à la touche "g". Vous pouvez désormais voir la liste des points, les courbes représentant les différentes méthodes d'approximation, ainsi que la liste de points à droite.

De plus, si jamais vous voulez rajouter des points à la liste, cette fonctionnalité est disponible grâce au bouton gauche de la souris. Le bouton droit aura pour effet de supprimer le point sélectionné.

Le curseur aura alors une position (x et y) qui sera automatiquement ajouté dans la liste des points. Les courbes ainsi que les polynômes vont s'adapter automatiquement !

D'autre part, vous pouvez zoomer et dézoomer grâce à la molette de la souris.

Enfin, vous pouvez activer ou désactiver les différentes courbes des fonctions en appuyant sur leur nom.
\end{enumerate}


\subsection{Fin de SDL}
\label{sec:orga3f22d4}

La fonction \emph{end-sdl} nous permet de fermet la fenêtre SDL proprement, ainsi que faire les opérations nécessaires pour vider la mémoire qui a besoin d'être libéré.






\section{Conclusion}
\label{sec:orge6a9472}

Maintenant, on vous souhaite bonne chance.
\end{document}